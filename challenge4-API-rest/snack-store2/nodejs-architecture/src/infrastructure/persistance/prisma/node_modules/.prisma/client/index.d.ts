
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model CLIENTS
 */

export type CLIENTS = {
  id: string
  name: string | null
  password: string | null
  state: number | null
}

/**
 * Model LIKES
 */

export type LIKES = {
  id: number
  idproduct: string | null
  idclient: string | null
  register: Date | null
}

/**
 * Model PRODUCTS
 */

export type PRODUCTS = {
  id: string
  name: string | null
  description: string | null
  image: number | null
  create: Date | null
}

/**
 * Model SALES
 */

export type SALES = {
  idproduct: string | null
  idclient: string | null
  quantity: number | null
  register: Date | null
  amount: Prisma.Decimal | null
  id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CLIENTS
 * const cLIENTS = await prisma.cLIENTS.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CLIENTS
   * const cLIENTS = await prisma.cLIENTS.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw < T = any > (query: string | TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>

      /**
   * `prisma.cLIENTS`: Exposes CRUD operations for the **CLIENTS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CLIENTS
    * const cLIENTS = await prisma.cLIENTS.findMany()
    * ```
    */
  get cLIENTS(): Prisma.CLIENTSDelegate<GlobalReject>;

  /**
   * `prisma.lIKES`: Exposes CRUD operations for the **LIKES** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LIKES
    * const lIKES = await prisma.lIKES.findMany()
    * ```
    */
  get lIKES(): Prisma.LIKESDelegate<GlobalReject>;

  /**
   * `prisma.pRODUCTS`: Exposes CRUD operations for the **PRODUCTS** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PRODUCTS
    * const pRODUCTS = await prisma.pRODUCTS.findMany()
    * ```
    */
  get pRODUCTS(): Prisma.PRODUCTSDelegate<GlobalReject>;

  /**
   * `prisma.sALES`: Exposes CRUD operations for the **SALES** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SALES
    * const sALES = await prisma.sALES.findMany()
    * ```
    */
  get sALES(): Prisma.SALESDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 2.19.0
   * Query Engine version: c1455d0b443d66b0d9db9bcb1bb9ee0d5bbc511d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}
 
  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | null | JsonObject | JsonArray

  /**
   * Same as JsonObject, but allows undefined
   */
  export type InputJsonObject = {[Key in string]?: JsonValue}
 
  export interface InputJsonArray extends Array<JsonValue> {}
 
  export type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray
   type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = (T | U) extends object ? (Without<T, U> & U) | (Without<U, T> & T) : T | U;


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  export type Union = any

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, 'avg' | 'sum' | 'count' | 'min' | 'max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    CLIENTS: 'CLIENTS',
    LIKES: 'LIKES',
    PRODUCTS: 'PRODUCTS',
    SALES: 'SALES'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }


  /**
   * Model CLIENTS
   */


  export type AggregateCLIENTS = {
    count: CLIENTSCountAggregateOutputType | null
    avg: CLIENTSAvgAggregateOutputType | null
    sum: CLIENTSSumAggregateOutputType | null
    min: CLIENTSMinAggregateOutputType | null
    max: CLIENTSMaxAggregateOutputType | null
  }

  export type CLIENTSAvgAggregateOutputType = {
    state: number | null
  }

  export type CLIENTSSumAggregateOutputType = {
    state: number | null
  }

  export type CLIENTSMinAggregateOutputType = {
    id: string | null
    name: string | null
    password: string | null
    state: number | null
  }

  export type CLIENTSMaxAggregateOutputType = {
    id: string | null
    name: string | null
    password: string | null
    state: number | null
  }

  export type CLIENTSCountAggregateOutputType = {
    id: number | null
    name: number | null
    password: number | null
    state: number | null
    _all: number
  }


  export type CLIENTSAvgAggregateInputType = {
    state?: true
  }

  export type CLIENTSSumAggregateInputType = {
    state?: true
  }

  export type CLIENTSMinAggregateInputType = {
    id?: true
    name?: true
    password?: true
    state?: true
  }

  export type CLIENTSMaxAggregateInputType = {
    id?: true
    name?: true
    password?: true
    state?: true
  }

  export type CLIENTSCountAggregateInputType = {
    id?: true
    name?: true
    password?: true
    state?: true
    _all?: true
  }

  export type CLIENTSAggregateArgs = {
    /**
     * Filter which CLIENTS to aggregate.
    **/
    where?: CLIENTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CLIENTS to fetch.
    **/
    orderBy?: Enumerable<CLIENTSOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: CLIENTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CLIENTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CLIENTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CLIENTS
    **/
    count?: true | CLIENTSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: CLIENTSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: CLIENTSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: CLIENTSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: CLIENTSMaxAggregateInputType
  }

  export type GetCLIENTSAggregateType<T extends CLIENTSAggregateArgs> = {
    [P in keyof T & keyof AggregateCLIENTS]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCLIENTS[P]>
      : GetScalarType<T[P], AggregateCLIENTS[P]>
  }



  export type CLIENTSSelect = {
    id?: boolean
    name?: boolean
    password?: boolean
    state?: boolean
    LIKES?: boolean | LIKESFindManyArgs
  }

  export type CLIENTSInclude = {
    LIKES?: boolean | LIKESFindManyArgs
  }

  export type CLIENTSGetPayload<
    S extends boolean | null | undefined | CLIENTSArgs,
    U = keyof S
      > = S extends true
        ? CLIENTS
    : S extends undefined
    ? never
    : S extends CLIENTSArgs | CLIENTSFindManyArgs
    ?'include' extends U
    ? CLIENTS  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'LIKES'
        ? Array < LIKESGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof CLIENTS ?CLIENTS [P]
  : 
          P extends 'LIKES'
        ? Array < LIKESGetPayload<S['select'][P]>>  : never
  } 
    : CLIENTS
  : CLIENTS


  type CLIENTSCountArgs = Merge<
    Omit<CLIENTSFindManyArgs, 'select' | 'include'> & {
      select?: CLIENTSCountAggregateInputType | true
    }
  >

  export interface CLIENTSDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one CLIENTS that matches the filter.
     * @param {CLIENTSFindUniqueArgs} args - Arguments to find a CLIENTS
     * @example
     * // Get one CLIENTS
     * const cLIENTS = await prisma.cLIENTS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CLIENTSFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CLIENTSFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'CLIENTS'> extends True ? CheckSelect<T, Prisma__CLIENTSClient<CLIENTS>, Prisma__CLIENTSClient<CLIENTSGetPayload<T>>> : CheckSelect<T, Prisma__CLIENTSClient<CLIENTS | null >, Prisma__CLIENTSClient<CLIENTSGetPayload<T> | null >>

    /**
     * Find the first CLIENTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CLIENTSFindFirstArgs} args - Arguments to find a CLIENTS
     * @example
     * // Get one CLIENTS
     * const cLIENTS = await prisma.cLIENTS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CLIENTSFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CLIENTSFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'CLIENTS'> extends True ? CheckSelect<T, Prisma__CLIENTSClient<CLIENTS>, Prisma__CLIENTSClient<CLIENTSGetPayload<T>>> : CheckSelect<T, Prisma__CLIENTSClient<CLIENTS | null >, Prisma__CLIENTSClient<CLIENTSGetPayload<T> | null >>

    /**
     * Find zero or more CLIENTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CLIENTSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CLIENTS
     * const cLIENTS = await prisma.cLIENTS.findMany()
     * 
     * // Get first 10 CLIENTS
     * const cLIENTS = await prisma.cLIENTS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cLIENTSWithIdOnly = await prisma.cLIENTS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CLIENTSFindManyArgs>(
      args?: SelectSubset<T, CLIENTSFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<CLIENTS>>, PrismaPromise<Array<CLIENTSGetPayload<T>>>>

    /**
     * Create a CLIENTS.
     * @param {CLIENTSCreateArgs} args - Arguments to create a CLIENTS.
     * @example
     * // Create one CLIENTS
     * const CLIENTS = await prisma.cLIENTS.create({
     *   data: {
     *     // ... data to create a CLIENTS
     *   }
     * })
     * 
    **/
    create<T extends CLIENTSCreateArgs>(
      args: SelectSubset<T, CLIENTSCreateArgs>
    ): CheckSelect<T, Prisma__CLIENTSClient<CLIENTS>, Prisma__CLIENTSClient<CLIENTSGetPayload<T>>>

    /**
     * Delete a CLIENTS.
     * @param {CLIENTSDeleteArgs} args - Arguments to delete one CLIENTS.
     * @example
     * // Delete one CLIENTS
     * const CLIENTS = await prisma.cLIENTS.delete({
     *   where: {
     *     // ... filter to delete one CLIENTS
     *   }
     * })
     * 
    **/
    delete<T extends CLIENTSDeleteArgs>(
      args: SelectSubset<T, CLIENTSDeleteArgs>
    ): CheckSelect<T, Prisma__CLIENTSClient<CLIENTS>, Prisma__CLIENTSClient<CLIENTSGetPayload<T>>>

    /**
     * Update one CLIENTS.
     * @param {CLIENTSUpdateArgs} args - Arguments to update one CLIENTS.
     * @example
     * // Update one CLIENTS
     * const cLIENTS = await prisma.cLIENTS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CLIENTSUpdateArgs>(
      args: SelectSubset<T, CLIENTSUpdateArgs>
    ): CheckSelect<T, Prisma__CLIENTSClient<CLIENTS>, Prisma__CLIENTSClient<CLIENTSGetPayload<T>>>

    /**
     * Delete zero or more CLIENTS.
     * @param {CLIENTSDeleteManyArgs} args - Arguments to filter CLIENTS to delete.
     * @example
     * // Delete a few CLIENTS
     * const { count } = await prisma.cLIENTS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CLIENTSDeleteManyArgs>(
      args?: SelectSubset<T, CLIENTSDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more CLIENTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CLIENTSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CLIENTS
     * const cLIENTS = await prisma.cLIENTS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CLIENTSUpdateManyArgs>(
      args: SelectSubset<T, CLIENTSUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one CLIENTS.
     * @param {CLIENTSUpsertArgs} args - Arguments to update or create a CLIENTS.
     * @example
     * // Update or create a CLIENTS
     * const cLIENTS = await prisma.cLIENTS.upsert({
     *   create: {
     *     // ... data to create a CLIENTS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CLIENTS we want to update
     *   }
     * })
    **/
    upsert<T extends CLIENTSUpsertArgs>(
      args: SelectSubset<T, CLIENTSUpsertArgs>
    ): CheckSelect<T, Prisma__CLIENTSClient<CLIENTS>, Prisma__CLIENTSClient<CLIENTSGetPayload<T>>>

    /**
     * Count the number of CLIENTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CLIENTSCountArgs} args - Arguments to filter CLIENTS to count.
     * @example
     * // Count the number of CLIENTS
     * const count = await prisma.cLIENTS.count({
     *   where: {
     *     // ... the filter for the CLIENTS we want to count
     *   }
     * })
    **/
    count<T extends CLIENTSCountArgs>(
      args?: Subset<T, CLIENTSCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CLIENTSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CLIENTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CLIENTSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CLIENTSAggregateArgs>(args: Subset<T, CLIENTSAggregateArgs>): PrismaPromise<GetCLIENTSAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for CLIENTS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CLIENTSClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    LIKES<T extends LIKESFindManyArgs = {}>(args?: Subset<T, LIKESFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LIKES>>, PrismaPromise<Array<LIKESGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * CLIENTS findUnique
   */
  export type CLIENTSFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * Throw an Error if a CLIENTS can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CLIENTS to fetch.
    **/
    where: CLIENTSWhereUniqueInput
  }


  /**
   * CLIENTS findFirst
   */
  export type CLIENTSFindFirstArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * Throw an Error if a CLIENTS can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which CLIENTS to fetch.
    **/
    where?: CLIENTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CLIENTS to fetch.
    **/
    orderBy?: Enumerable<CLIENTSOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CLIENTS.
    **/
    cursor?: CLIENTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CLIENTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CLIENTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CLIENTS.
    **/
    distinct?: Enumerable<CLIENTSScalarFieldEnum>
  }


  /**
   * CLIENTS findMany
   */
  export type CLIENTSFindManyArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * Filter, which CLIENTS to fetch.
    **/
    where?: CLIENTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CLIENTS to fetch.
    **/
    orderBy?: Enumerable<CLIENTSOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CLIENTS.
    **/
    cursor?: CLIENTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CLIENTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CLIENTS.
    **/
    skip?: number
    distinct?: Enumerable<CLIENTSScalarFieldEnum>
  }


  /**
   * CLIENTS create
   */
  export type CLIENTSCreateArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * The data needed to create a CLIENTS.
    **/
    data: XOR<CLIENTSCreateInput, CLIENTSUncheckedCreateInput>
  }


  /**
   * CLIENTS update
   */
  export type CLIENTSUpdateArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * The data needed to update a CLIENTS.
    **/
    data: XOR<CLIENTSUpdateInput, CLIENTSUncheckedUpdateInput>
    /**
     * Choose, which CLIENTS to update.
    **/
    where: CLIENTSWhereUniqueInput
  }


  /**
   * CLIENTS updateMany
   */
  export type CLIENTSUpdateManyArgs = {
    data: XOR<CLIENTSUpdateManyMutationInput, CLIENTSUncheckedUpdateManyInput>
    where?: CLIENTSWhereInput
  }


  /**
   * CLIENTS upsert
   */
  export type CLIENTSUpsertArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * The filter to search for the CLIENTS to update in case it exists.
    **/
    where: CLIENTSWhereUniqueInput
    /**
     * In case the CLIENTS found by the `where` argument doesn't exist, create a new CLIENTS with this data.
    **/
    create: XOR<CLIENTSCreateInput, CLIENTSUncheckedCreateInput>
    /**
     * In case the CLIENTS was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<CLIENTSUpdateInput, CLIENTSUncheckedUpdateInput>
  }


  /**
   * CLIENTS delete
   */
  export type CLIENTSDeleteArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
    /**
     * Filter which CLIENTS to delete.
    **/
    where: CLIENTSWhereUniqueInput
  }


  /**
   * CLIENTS deleteMany
   */
  export type CLIENTSDeleteManyArgs = {
    where?: CLIENTSWhereInput
  }


  /**
   * CLIENTS without action
   */
  export type CLIENTSArgs = {
    /**
     * Select specific fields to fetch from the CLIENTS
    **/
    select?: CLIENTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: CLIENTSInclude | null
  }



  /**
   * Model LIKES
   */


  export type AggregateLIKES = {
    count: LIKESCountAggregateOutputType | null
    avg: LIKESAvgAggregateOutputType | null
    sum: LIKESSumAggregateOutputType | null
    min: LIKESMinAggregateOutputType | null
    max: LIKESMaxAggregateOutputType | null
  }

  export type LIKESAvgAggregateOutputType = {
    id: number
  }

  export type LIKESSumAggregateOutputType = {
    id: number
  }

  export type LIKESMinAggregateOutputType = {
    id: number
    idproduct: string | null
    idclient: string | null
    register: Date | null
  }

  export type LIKESMaxAggregateOutputType = {
    id: number
    idproduct: string | null
    idclient: string | null
    register: Date | null
  }

  export type LIKESCountAggregateOutputType = {
    id: number
    idproduct: number | null
    idclient: number | null
    register: number | null
    _all: number
  }


  export type LIKESAvgAggregateInputType = {
    id?: true
  }

  export type LIKESSumAggregateInputType = {
    id?: true
  }

  export type LIKESMinAggregateInputType = {
    id?: true
    idproduct?: true
    idclient?: true
    register?: true
  }

  export type LIKESMaxAggregateInputType = {
    id?: true
    idproduct?: true
    idclient?: true
    register?: true
  }

  export type LIKESCountAggregateInputType = {
    id?: true
    idproduct?: true
    idclient?: true
    register?: true
    _all?: true
  }

  export type LIKESAggregateArgs = {
    /**
     * Filter which LIKES to aggregate.
    **/
    where?: LIKESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LIKES to fetch.
    **/
    orderBy?: Enumerable<LIKESOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: LIKESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LIKES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LIKES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LIKES
    **/
    count?: true | LIKESCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: LIKESAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: LIKESSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: LIKESMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: LIKESMaxAggregateInputType
  }

  export type GetLIKESAggregateType<T extends LIKESAggregateArgs> = {
    [P in keyof T & keyof AggregateLIKES]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLIKES[P]>
      : GetScalarType<T[P], AggregateLIKES[P]>
  }



  export type LIKESSelect = {
    id?: boolean
    idproduct?: boolean
    idclient?: boolean
    register?: boolean
    CLIENTS?: boolean | CLIENTSArgs
    PRODUCTS?: boolean | PRODUCTSArgs
  }

  export type LIKESInclude = {
    CLIENTS?: boolean | CLIENTSArgs
    PRODUCTS?: boolean | PRODUCTSArgs
  }

  export type LIKESGetPayload<
    S extends boolean | null | undefined | LIKESArgs,
    U = keyof S
      > = S extends true
        ? LIKES
    : S extends undefined
    ? never
    : S extends LIKESArgs | LIKESFindManyArgs
    ?'include' extends U
    ? LIKES  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'CLIENTS'
        ? CLIENTSGetPayload<S['include'][P]> | null :
        P extends 'PRODUCTS'
        ? PRODUCTSGetPayload<S['include'][P]> | null : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof LIKES ?LIKES [P]
  : 
          P extends 'CLIENTS'
        ? CLIENTSGetPayload<S['select'][P]> | null :
        P extends 'PRODUCTS'
        ? PRODUCTSGetPayload<S['select'][P]> | null : never
  } 
    : LIKES
  : LIKES


  type LIKESCountArgs = Merge<
    Omit<LIKESFindManyArgs, 'select' | 'include'> & {
      select?: LIKESCountAggregateInputType | true
    }
  >

  export interface LIKESDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one LIKES that matches the filter.
     * @param {LIKESFindUniqueArgs} args - Arguments to find a LIKES
     * @example
     * // Get one LIKES
     * const lIKES = await prisma.lIKES.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LIKESFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LIKESFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'LIKES'> extends True ? CheckSelect<T, Prisma__LIKESClient<LIKES>, Prisma__LIKESClient<LIKESGetPayload<T>>> : CheckSelect<T, Prisma__LIKESClient<LIKES | null >, Prisma__LIKESClient<LIKESGetPayload<T> | null >>

    /**
     * Find the first LIKES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LIKESFindFirstArgs} args - Arguments to find a LIKES
     * @example
     * // Get one LIKES
     * const lIKES = await prisma.lIKES.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LIKESFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LIKESFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'LIKES'> extends True ? CheckSelect<T, Prisma__LIKESClient<LIKES>, Prisma__LIKESClient<LIKESGetPayload<T>>> : CheckSelect<T, Prisma__LIKESClient<LIKES | null >, Prisma__LIKESClient<LIKESGetPayload<T> | null >>

    /**
     * Find zero or more LIKES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LIKESFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LIKES
     * const lIKES = await prisma.lIKES.findMany()
     * 
     * // Get first 10 LIKES
     * const lIKES = await prisma.lIKES.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lIKESWithIdOnly = await prisma.lIKES.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LIKESFindManyArgs>(
      args?: SelectSubset<T, LIKESFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<LIKES>>, PrismaPromise<Array<LIKESGetPayload<T>>>>

    /**
     * Create a LIKES.
     * @param {LIKESCreateArgs} args - Arguments to create a LIKES.
     * @example
     * // Create one LIKES
     * const LIKES = await prisma.lIKES.create({
     *   data: {
     *     // ... data to create a LIKES
     *   }
     * })
     * 
    **/
    create<T extends LIKESCreateArgs>(
      args: SelectSubset<T, LIKESCreateArgs>
    ): CheckSelect<T, Prisma__LIKESClient<LIKES>, Prisma__LIKESClient<LIKESGetPayload<T>>>

    /**
     * Delete a LIKES.
     * @param {LIKESDeleteArgs} args - Arguments to delete one LIKES.
     * @example
     * // Delete one LIKES
     * const LIKES = await prisma.lIKES.delete({
     *   where: {
     *     // ... filter to delete one LIKES
     *   }
     * })
     * 
    **/
    delete<T extends LIKESDeleteArgs>(
      args: SelectSubset<T, LIKESDeleteArgs>
    ): CheckSelect<T, Prisma__LIKESClient<LIKES>, Prisma__LIKESClient<LIKESGetPayload<T>>>

    /**
     * Update one LIKES.
     * @param {LIKESUpdateArgs} args - Arguments to update one LIKES.
     * @example
     * // Update one LIKES
     * const lIKES = await prisma.lIKES.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LIKESUpdateArgs>(
      args: SelectSubset<T, LIKESUpdateArgs>
    ): CheckSelect<T, Prisma__LIKESClient<LIKES>, Prisma__LIKESClient<LIKESGetPayload<T>>>

    /**
     * Delete zero or more LIKES.
     * @param {LIKESDeleteManyArgs} args - Arguments to filter LIKES to delete.
     * @example
     * // Delete a few LIKES
     * const { count } = await prisma.lIKES.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LIKESDeleteManyArgs>(
      args?: SelectSubset<T, LIKESDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more LIKES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LIKESUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LIKES
     * const lIKES = await prisma.lIKES.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LIKESUpdateManyArgs>(
      args: SelectSubset<T, LIKESUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one LIKES.
     * @param {LIKESUpsertArgs} args - Arguments to update or create a LIKES.
     * @example
     * // Update or create a LIKES
     * const lIKES = await prisma.lIKES.upsert({
     *   create: {
     *     // ... data to create a LIKES
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LIKES we want to update
     *   }
     * })
    **/
    upsert<T extends LIKESUpsertArgs>(
      args: SelectSubset<T, LIKESUpsertArgs>
    ): CheckSelect<T, Prisma__LIKESClient<LIKES>, Prisma__LIKESClient<LIKESGetPayload<T>>>

    /**
     * Count the number of LIKES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LIKESCountArgs} args - Arguments to filter LIKES to count.
     * @example
     * // Count the number of LIKES
     * const count = await prisma.lIKES.count({
     *   where: {
     *     // ... the filter for the LIKES we want to count
     *   }
     * })
    **/
    count<T extends LIKESCountArgs>(
      args?: Subset<T, LIKESCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LIKESCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LIKES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LIKESAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LIKESAggregateArgs>(args: Subset<T, LIKESAggregateArgs>): PrismaPromise<GetLIKESAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for LIKES.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LIKESClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    CLIENTS<T extends CLIENTSArgs = {}>(args?: Subset<T, CLIENTSArgs>): CheckSelect<T, Prisma__CLIENTSClient<CLIENTS | null >, Prisma__CLIENTSClient<CLIENTSGetPayload<T> | null >>;

    PRODUCTS<T extends PRODUCTSArgs = {}>(args?: Subset<T, PRODUCTSArgs>): CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS | null >, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * LIKES findUnique
   */
  export type LIKESFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * Throw an Error if a LIKES can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LIKES to fetch.
    **/
    where: LIKESWhereUniqueInput
  }


  /**
   * LIKES findFirst
   */
  export type LIKESFindFirstArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * Throw an Error if a LIKES can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which LIKES to fetch.
    **/
    where?: LIKESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LIKES to fetch.
    **/
    orderBy?: Enumerable<LIKESOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LIKES.
    **/
    cursor?: LIKESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LIKES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LIKES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LIKES.
    **/
    distinct?: Enumerable<LIKESScalarFieldEnum>
  }


  /**
   * LIKES findMany
   */
  export type LIKESFindManyArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * Filter, which LIKES to fetch.
    **/
    where?: LIKESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LIKES to fetch.
    **/
    orderBy?: Enumerable<LIKESOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LIKES.
    **/
    cursor?: LIKESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LIKES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LIKES.
    **/
    skip?: number
    distinct?: Enumerable<LIKESScalarFieldEnum>
  }


  /**
   * LIKES create
   */
  export type LIKESCreateArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * The data needed to create a LIKES.
    **/
    data: XOR<LIKESCreateInput, LIKESUncheckedCreateInput>
  }


  /**
   * LIKES update
   */
  export type LIKESUpdateArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * The data needed to update a LIKES.
    **/
    data: XOR<LIKESUpdateInput, LIKESUncheckedUpdateInput>
    /**
     * Choose, which LIKES to update.
    **/
    where: LIKESWhereUniqueInput
  }


  /**
   * LIKES updateMany
   */
  export type LIKESUpdateManyArgs = {
    data: XOR<LIKESUpdateManyMutationInput, LIKESUncheckedUpdateManyInput>
    where?: LIKESWhereInput
  }


  /**
   * LIKES upsert
   */
  export type LIKESUpsertArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * The filter to search for the LIKES to update in case it exists.
    **/
    where: LIKESWhereUniqueInput
    /**
     * In case the LIKES found by the `where` argument doesn't exist, create a new LIKES with this data.
    **/
    create: XOR<LIKESCreateInput, LIKESUncheckedCreateInput>
    /**
     * In case the LIKES was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<LIKESUpdateInput, LIKESUncheckedUpdateInput>
  }


  /**
   * LIKES delete
   */
  export type LIKESDeleteArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
    /**
     * Filter which LIKES to delete.
    **/
    where: LIKESWhereUniqueInput
  }


  /**
   * LIKES deleteMany
   */
  export type LIKESDeleteManyArgs = {
    where?: LIKESWhereInput
  }


  /**
   * LIKES without action
   */
  export type LIKESArgs = {
    /**
     * Select specific fields to fetch from the LIKES
    **/
    select?: LIKESSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: LIKESInclude | null
  }



  /**
   * Model PRODUCTS
   */


  export type AggregatePRODUCTS = {
    count: PRODUCTSCountAggregateOutputType | null
    avg: PRODUCTSAvgAggregateOutputType | null
    sum: PRODUCTSSumAggregateOutputType | null
    min: PRODUCTSMinAggregateOutputType | null
    max: PRODUCTSMaxAggregateOutputType | null
  }

  export type PRODUCTSAvgAggregateOutputType = {
    image: number | null
  }

  export type PRODUCTSSumAggregateOutputType = {
    image: number | null
  }

  export type PRODUCTSMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: number | null
    create: Date | null
  }

  export type PRODUCTSMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    image: number | null
    create: Date | null
  }

  export type PRODUCTSCountAggregateOutputType = {
    id: number | null
    name: number | null
    description: number | null
    image: number | null
    create: number | null
    _all: number
  }


  export type PRODUCTSAvgAggregateInputType = {
    image?: true
  }

  export type PRODUCTSSumAggregateInputType = {
    image?: true
  }

  export type PRODUCTSMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    create?: true
  }

  export type PRODUCTSMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    create?: true
  }

  export type PRODUCTSCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    image?: true
    create?: true
    _all?: true
  }

  export type PRODUCTSAggregateArgs = {
    /**
     * Filter which PRODUCTS to aggregate.
    **/
    where?: PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRODUCTS to fetch.
    **/
    orderBy?: Enumerable<PRODUCTSOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRODUCTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRODUCTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PRODUCTS
    **/
    count?: true | PRODUCTSCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: PRODUCTSAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: PRODUCTSSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: PRODUCTSMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: PRODUCTSMaxAggregateInputType
  }

  export type GetPRODUCTSAggregateType<T extends PRODUCTSAggregateArgs> = {
    [P in keyof T & keyof AggregatePRODUCTS]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePRODUCTS[P]>
      : GetScalarType<T[P], AggregatePRODUCTS[P]>
  }



  export type PRODUCTSSelect = {
    id?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    create?: boolean
    LIKES?: boolean | LIKESFindManyArgs
  }

  export type PRODUCTSInclude = {
    LIKES?: boolean | LIKESFindManyArgs
  }

  export type PRODUCTSGetPayload<
    S extends boolean | null | undefined | PRODUCTSArgs,
    U = keyof S
      > = S extends true
        ? PRODUCTS
    : S extends undefined
    ? never
    : S extends PRODUCTSArgs | PRODUCTSFindManyArgs
    ?'include' extends U
    ? PRODUCTS  & {
    [P in TrueKeys<S['include']>]: 
          P extends 'LIKES'
        ? Array < LIKESGetPayload<S['include'][P]>>  : never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof PRODUCTS ?PRODUCTS [P]
  : 
          P extends 'LIKES'
        ? Array < LIKESGetPayload<S['select'][P]>>  : never
  } 
    : PRODUCTS
  : PRODUCTS


  type PRODUCTSCountArgs = Merge<
    Omit<PRODUCTSFindManyArgs, 'select' | 'include'> & {
      select?: PRODUCTSCountAggregateInputType | true
    }
  >

  export interface PRODUCTSDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PRODUCTS that matches the filter.
     * @param {PRODUCTSFindUniqueArgs} args - Arguments to find a PRODUCTS
     * @example
     * // Get one PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PRODUCTSFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PRODUCTSFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PRODUCTS'> extends True ? CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS>, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T>>> : CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS | null >, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T> | null >>

    /**
     * Find the first PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRODUCTSFindFirstArgs} args - Arguments to find a PRODUCTS
     * @example
     * // Get one PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PRODUCTSFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PRODUCTSFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PRODUCTS'> extends True ? CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS>, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T>>> : CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS | null >, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T> | null >>

    /**
     * Find zero or more PRODUCTS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRODUCTSFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.findMany()
     * 
     * // Get first 10 PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pRODUCTSWithIdOnly = await prisma.pRODUCTS.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PRODUCTSFindManyArgs>(
      args?: SelectSubset<T, PRODUCTSFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PRODUCTS>>, PrismaPromise<Array<PRODUCTSGetPayload<T>>>>

    /**
     * Create a PRODUCTS.
     * @param {PRODUCTSCreateArgs} args - Arguments to create a PRODUCTS.
     * @example
     * // Create one PRODUCTS
     * const PRODUCTS = await prisma.pRODUCTS.create({
     *   data: {
     *     // ... data to create a PRODUCTS
     *   }
     * })
     * 
    **/
    create<T extends PRODUCTSCreateArgs>(
      args: SelectSubset<T, PRODUCTSCreateArgs>
    ): CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS>, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T>>>

    /**
     * Delete a PRODUCTS.
     * @param {PRODUCTSDeleteArgs} args - Arguments to delete one PRODUCTS.
     * @example
     * // Delete one PRODUCTS
     * const PRODUCTS = await prisma.pRODUCTS.delete({
     *   where: {
     *     // ... filter to delete one PRODUCTS
     *   }
     * })
     * 
    **/
    delete<T extends PRODUCTSDeleteArgs>(
      args: SelectSubset<T, PRODUCTSDeleteArgs>
    ): CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS>, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T>>>

    /**
     * Update one PRODUCTS.
     * @param {PRODUCTSUpdateArgs} args - Arguments to update one PRODUCTS.
     * @example
     * // Update one PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PRODUCTSUpdateArgs>(
      args: SelectSubset<T, PRODUCTSUpdateArgs>
    ): CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS>, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T>>>

    /**
     * Delete zero or more PRODUCTS.
     * @param {PRODUCTSDeleteManyArgs} args - Arguments to filter PRODUCTS to delete.
     * @example
     * // Delete a few PRODUCTS
     * const { count } = await prisma.pRODUCTS.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PRODUCTSDeleteManyArgs>(
      args?: SelectSubset<T, PRODUCTSDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRODUCTSUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PRODUCTSUpdateManyArgs>(
      args: SelectSubset<T, PRODUCTSUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PRODUCTS.
     * @param {PRODUCTSUpsertArgs} args - Arguments to update or create a PRODUCTS.
     * @example
     * // Update or create a PRODUCTS
     * const pRODUCTS = await prisma.pRODUCTS.upsert({
     *   create: {
     *     // ... data to create a PRODUCTS
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PRODUCTS we want to update
     *   }
     * })
    **/
    upsert<T extends PRODUCTSUpsertArgs>(
      args: SelectSubset<T, PRODUCTSUpsertArgs>
    ): CheckSelect<T, Prisma__PRODUCTSClient<PRODUCTS>, Prisma__PRODUCTSClient<PRODUCTSGetPayload<T>>>

    /**
     * Count the number of PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRODUCTSCountArgs} args - Arguments to filter PRODUCTS to count.
     * @example
     * // Count the number of PRODUCTS
     * const count = await prisma.pRODUCTS.count({
     *   where: {
     *     // ... the filter for the PRODUCTS we want to count
     *   }
     * })
    **/
    count<T extends PRODUCTSCountArgs>(
      args?: Subset<T, PRODUCTSCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PRODUCTSCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PRODUCTS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PRODUCTSAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PRODUCTSAggregateArgs>(args: Subset<T, PRODUCTSAggregateArgs>): PrismaPromise<GetPRODUCTSAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for PRODUCTS.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PRODUCTSClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    LIKES<T extends LIKESFindManyArgs = {}>(args?: Subset<T, LIKESFindManyArgs>): CheckSelect<T, PrismaPromise<Array<LIKES>>, PrismaPromise<Array<LIKESGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PRODUCTS findUnique
   */
  export type PRODUCTSFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * Throw an Error if a PRODUCTS can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PRODUCTS to fetch.
    **/
    where: PRODUCTSWhereUniqueInput
  }


  /**
   * PRODUCTS findFirst
   */
  export type PRODUCTSFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * Throw an Error if a PRODUCTS can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PRODUCTS to fetch.
    **/
    where?: PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRODUCTS to fetch.
    **/
    orderBy?: Enumerable<PRODUCTSOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PRODUCTS.
    **/
    cursor?: PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRODUCTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRODUCTS.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PRODUCTS.
    **/
    distinct?: Enumerable<PRODUCTSScalarFieldEnum>
  }


  /**
   * PRODUCTS findMany
   */
  export type PRODUCTSFindManyArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * Filter, which PRODUCTS to fetch.
    **/
    where?: PRODUCTSWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PRODUCTS to fetch.
    **/
    orderBy?: Enumerable<PRODUCTSOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PRODUCTS.
    **/
    cursor?: PRODUCTSWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PRODUCTS from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PRODUCTS.
    **/
    skip?: number
    distinct?: Enumerable<PRODUCTSScalarFieldEnum>
  }


  /**
   * PRODUCTS create
   */
  export type PRODUCTSCreateArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * The data needed to create a PRODUCTS.
    **/
    data: XOR<PRODUCTSCreateInput, PRODUCTSUncheckedCreateInput>
  }


  /**
   * PRODUCTS update
   */
  export type PRODUCTSUpdateArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * The data needed to update a PRODUCTS.
    **/
    data: XOR<PRODUCTSUpdateInput, PRODUCTSUncheckedUpdateInput>
    /**
     * Choose, which PRODUCTS to update.
    **/
    where: PRODUCTSWhereUniqueInput
  }


  /**
   * PRODUCTS updateMany
   */
  export type PRODUCTSUpdateManyArgs = {
    data: XOR<PRODUCTSUpdateManyMutationInput, PRODUCTSUncheckedUpdateManyInput>
    where?: PRODUCTSWhereInput
  }


  /**
   * PRODUCTS upsert
   */
  export type PRODUCTSUpsertArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * The filter to search for the PRODUCTS to update in case it exists.
    **/
    where: PRODUCTSWhereUniqueInput
    /**
     * In case the PRODUCTS found by the `where` argument doesn't exist, create a new PRODUCTS with this data.
    **/
    create: XOR<PRODUCTSCreateInput, PRODUCTSUncheckedCreateInput>
    /**
     * In case the PRODUCTS was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<PRODUCTSUpdateInput, PRODUCTSUncheckedUpdateInput>
  }


  /**
   * PRODUCTS delete
   */
  export type PRODUCTSDeleteArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
    /**
     * Filter which PRODUCTS to delete.
    **/
    where: PRODUCTSWhereUniqueInput
  }


  /**
   * PRODUCTS deleteMany
   */
  export type PRODUCTSDeleteManyArgs = {
    where?: PRODUCTSWhereInput
  }


  /**
   * PRODUCTS without action
   */
  export type PRODUCTSArgs = {
    /**
     * Select specific fields to fetch from the PRODUCTS
    **/
    select?: PRODUCTSSelect | null
    /**
     * Choose, which related nodes to fetch as well.
    **/
    include?: PRODUCTSInclude | null
  }



  /**
   * Model SALES
   */


  export type AggregateSALES = {
    count: SALESCountAggregateOutputType | null
    avg: SALESAvgAggregateOutputType | null
    sum: SALESSumAggregateOutputType | null
    min: SALESMinAggregateOutputType | null
    max: SALESMaxAggregateOutputType | null
  }

  export type SALESAvgAggregateOutputType = {
    quantity: number | null
    amount: Decimal | null
    id: number
  }

  export type SALESSumAggregateOutputType = {
    quantity: number | null
    amount: Decimal | null
    id: number
  }

  export type SALESMinAggregateOutputType = {
    idproduct: string | null
    idclient: string | null
    quantity: number | null
    register: Date | null
    amount: Decimal | null
    id: number
  }

  export type SALESMaxAggregateOutputType = {
    idproduct: string | null
    idclient: string | null
    quantity: number | null
    register: Date | null
    amount: Decimal | null
    id: number
  }

  export type SALESCountAggregateOutputType = {
    idproduct: number | null
    idclient: number | null
    quantity: number | null
    register: number | null
    amount: number | null
    id: number
    _all: number
  }


  export type SALESAvgAggregateInputType = {
    quantity?: true
    amount?: true
    id?: true
  }

  export type SALESSumAggregateInputType = {
    quantity?: true
    amount?: true
    id?: true
  }

  export type SALESMinAggregateInputType = {
    idproduct?: true
    idclient?: true
    quantity?: true
    register?: true
    amount?: true
    id?: true
  }

  export type SALESMaxAggregateInputType = {
    idproduct?: true
    idclient?: true
    quantity?: true
    register?: true
    amount?: true
    id?: true
  }

  export type SALESCountAggregateInputType = {
    idproduct?: true
    idclient?: true
    quantity?: true
    register?: true
    amount?: true
    id?: true
    _all?: true
  }

  export type SALESAggregateArgs = {
    /**
     * Filter which SALES to aggregate.
    **/
    where?: SALESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALES to fetch.
    **/
    orderBy?: Enumerable<SALESOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
    **/
    cursor?: SALESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SALES
    **/
    count?: true | SALESCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    avg?: SALESAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    sum?: SALESSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    min?: SALESMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    max?: SALESMaxAggregateInputType
  }

  export type GetSALESAggregateType<T extends SALESAggregateArgs> = {
    [P in keyof T & keyof AggregateSALES]: P extends 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSALES[P]>
      : GetScalarType<T[P], AggregateSALES[P]>
  }



  export type SALESSelect = {
    idproduct?: boolean
    idclient?: boolean
    quantity?: boolean
    register?: boolean
    amount?: boolean
    id?: boolean
  }

  export type SALESGetPayload<
    S extends boolean | null | undefined | SALESArgs,
    U = keyof S
      > = S extends true
        ? SALES
    : S extends undefined
    ? never
    : S extends SALESArgs | SALESFindManyArgs
    ?'include' extends U
    ? SALES 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]: P extends keyof SALES ?SALES [P]
  : 
     never
  } 
    : SALES
  : SALES


  type SALESCountArgs = Merge<
    Omit<SALESFindManyArgs, 'select' | 'include'> & {
      select?: SALESCountAggregateInputType | true
    }
  >

  export interface SALESDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SALES that matches the filter.
     * @param {SALESFindUniqueArgs} args - Arguments to find a SALES
     * @example
     * // Get one SALES
     * const sALES = await prisma.sALES.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SALESFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SALESFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SALES'> extends True ? CheckSelect<T, Prisma__SALESClient<SALES>, Prisma__SALESClient<SALESGetPayload<T>>> : CheckSelect<T, Prisma__SALESClient<SALES | null >, Prisma__SALESClient<SALESGetPayload<T> | null >>

    /**
     * Find the first SALES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALESFindFirstArgs} args - Arguments to find a SALES
     * @example
     * // Get one SALES
     * const sALES = await prisma.sALES.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SALESFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SALESFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SALES'> extends True ? CheckSelect<T, Prisma__SALESClient<SALES>, Prisma__SALESClient<SALESGetPayload<T>>> : CheckSelect<T, Prisma__SALESClient<SALES | null >, Prisma__SALESClient<SALESGetPayload<T> | null >>

    /**
     * Find zero or more SALES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALESFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SALES
     * const sALES = await prisma.sALES.findMany()
     * 
     * // Get first 10 SALES
     * const sALES = await prisma.sALES.findMany({ take: 10 })
     * 
     * // Only select the `idproduct`
     * const sALESWithIdproductOnly = await prisma.sALES.findMany({ select: { idproduct: true } })
     * 
    **/
    findMany<T extends SALESFindManyArgs>(
      args?: SelectSubset<T, SALESFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SALES>>, PrismaPromise<Array<SALESGetPayload<T>>>>

    /**
     * Create a SALES.
     * @param {SALESCreateArgs} args - Arguments to create a SALES.
     * @example
     * // Create one SALES
     * const SALES = await prisma.sALES.create({
     *   data: {
     *     // ... data to create a SALES
     *   }
     * })
     * 
    **/
    create<T extends SALESCreateArgs>(
      args: SelectSubset<T, SALESCreateArgs>
    ): CheckSelect<T, Prisma__SALESClient<SALES>, Prisma__SALESClient<SALESGetPayload<T>>>

    /**
     * Delete a SALES.
     * @param {SALESDeleteArgs} args - Arguments to delete one SALES.
     * @example
     * // Delete one SALES
     * const SALES = await prisma.sALES.delete({
     *   where: {
     *     // ... filter to delete one SALES
     *   }
     * })
     * 
    **/
    delete<T extends SALESDeleteArgs>(
      args: SelectSubset<T, SALESDeleteArgs>
    ): CheckSelect<T, Prisma__SALESClient<SALES>, Prisma__SALESClient<SALESGetPayload<T>>>

    /**
     * Update one SALES.
     * @param {SALESUpdateArgs} args - Arguments to update one SALES.
     * @example
     * // Update one SALES
     * const sALES = await prisma.sALES.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SALESUpdateArgs>(
      args: SelectSubset<T, SALESUpdateArgs>
    ): CheckSelect<T, Prisma__SALESClient<SALES>, Prisma__SALESClient<SALESGetPayload<T>>>

    /**
     * Delete zero or more SALES.
     * @param {SALESDeleteManyArgs} args - Arguments to filter SALES to delete.
     * @example
     * // Delete a few SALES
     * const { count } = await prisma.sALES.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SALESDeleteManyArgs>(
      args?: SelectSubset<T, SALESDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SALES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALESUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SALES
     * const sALES = await prisma.sALES.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SALESUpdateManyArgs>(
      args: SelectSubset<T, SALESUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SALES.
     * @param {SALESUpsertArgs} args - Arguments to update or create a SALES.
     * @example
     * // Update or create a SALES
     * const sALES = await prisma.sALES.upsert({
     *   create: {
     *     // ... data to create a SALES
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SALES we want to update
     *   }
     * })
    **/
    upsert<T extends SALESUpsertArgs>(
      args: SelectSubset<T, SALESUpsertArgs>
    ): CheckSelect<T, Prisma__SALESClient<SALES>, Prisma__SALESClient<SALESGetPayload<T>>>

    /**
     * Count the number of SALES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALESCountArgs} args - Arguments to filter SALES to count.
     * @example
     * // Count the number of SALES
     * const count = await prisma.sALES.count({
     *   where: {
     *     // ... the filter for the SALES we want to count
     *   }
     * })
    **/
    count<T extends SALESCountArgs>(
      args?: Subset<T, SALESCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SALESCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SALES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SALESAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SALESAggregateArgs>(args: Subset<T, SALESAggregateArgs>): PrismaPromise<GetSALESAggregateType<T>>


  }

  /**
   * The delegate class that acts as a "Promise-like" for SALES.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in 
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SALESClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SALES findUnique
   */
  export type SALESFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * Throw an Error if a SALES can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SALES to fetch.
    **/
    where: SALESWhereUniqueInput
  }


  /**
   * SALES findFirst
   */
  export type SALESFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * Throw an Error if a SALES can't be found
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SALES to fetch.
    **/
    where?: SALESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALES to fetch.
    **/
    orderBy?: Enumerable<SALESOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SALES.
    **/
    cursor?: SALESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALES.
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SALES.
    **/
    distinct?: Enumerable<SALESScalarFieldEnum>
  }


  /**
   * SALES findMany
   */
  export type SALESFindManyArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * Filter, which SALES to fetch.
    **/
    where?: SALESWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SALES to fetch.
    **/
    orderBy?: Enumerable<SALESOrderByInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SALES.
    **/
    cursor?: SALESWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SALES from the position of the cursor.
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SALES.
    **/
    skip?: number
    distinct?: Enumerable<SALESScalarFieldEnum>
  }


  /**
   * SALES create
   */
  export type SALESCreateArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * The data needed to create a SALES.
    **/
    data: XOR<SALESCreateInput, SALESUncheckedCreateInput>
  }


  /**
   * SALES update
   */
  export type SALESUpdateArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * The data needed to update a SALES.
    **/
    data: XOR<SALESUpdateInput, SALESUncheckedUpdateInput>
    /**
     * Choose, which SALES to update.
    **/
    where: SALESWhereUniqueInput
  }


  /**
   * SALES updateMany
   */
  export type SALESUpdateManyArgs = {
    data: XOR<SALESUpdateManyMutationInput, SALESUncheckedUpdateManyInput>
    where?: SALESWhereInput
  }


  /**
   * SALES upsert
   */
  export type SALESUpsertArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * The filter to search for the SALES to update in case it exists.
    **/
    where: SALESWhereUniqueInput
    /**
     * In case the SALES found by the `where` argument doesn't exist, create a new SALES with this data.
    **/
    create: XOR<SALESCreateInput, SALESUncheckedCreateInput>
    /**
     * In case the SALES was found with the provided `where` argument, update it with this data.
    **/
    update: XOR<SALESUpdateInput, SALESUncheckedUpdateInput>
  }


  /**
   * SALES delete
   */
  export type SALESDeleteArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
    /**
     * Filter which SALES to delete.
    **/
    where: SALESWhereUniqueInput
  }


  /**
   * SALES deleteMany
   */
  export type SALESDeleteManyArgs = {
    where?: SALESWhereInput
  }


  /**
   * SALES without action
   */
  export type SALESArgs = {
    /**
     * Select specific fields to fetch from the SALES
    **/
    select?: SALESSelect | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const CLIENTSScalarFieldEnum: {
    id: 'id',
    name: 'name',
    password: 'password',
    state: 'state'
  };

  export type CLIENTSScalarFieldEnum = (typeof CLIENTSScalarFieldEnum)[keyof typeof CLIENTSScalarFieldEnum]


  export const LIKESScalarFieldEnum: {
    id: 'id',
    idproduct: 'idproduct',
    idclient: 'idclient',
    register: 'register'
  };

  export type LIKESScalarFieldEnum = (typeof LIKESScalarFieldEnum)[keyof typeof LIKESScalarFieldEnum]


  export const PRODUCTSScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    image: 'image',
    create: 'create'
  };

  export type PRODUCTSScalarFieldEnum = (typeof PRODUCTSScalarFieldEnum)[keyof typeof PRODUCTSScalarFieldEnum]


  export const SALESScalarFieldEnum: {
    idproduct: 'idproduct',
    idclient: 'idclient',
    quantity: 'quantity',
    register: 'register',
    amount: 'amount',
    id: 'id'
  };

  export type SALESScalarFieldEnum = (typeof SALESScalarFieldEnum)[keyof typeof SALESScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type CLIENTSWhereInput = {
    AND?: Enumerable<CLIENTSWhereInput>
    OR?: Enumerable<CLIENTSWhereInput>
    NOT?: Enumerable<CLIENTSWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    password?: StringNullableFilter | string | null
    state?: IntNullableFilter | number | null
    LIKES?: LIKESListRelationFilter
  }

  export type CLIENTSOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    password?: SortOrder
    state?: SortOrder
  }

  export type CLIENTSWhereUniqueInput = {
    id?: string
  }

  export type LIKESWhereInput = {
    AND?: Enumerable<LIKESWhereInput>
    OR?: Enumerable<LIKESWhereInput>
    NOT?: Enumerable<LIKESWhereInput>
    id?: IntFilter | number
    idproduct?: StringNullableFilter | string | null
    idclient?: StringNullableFilter | string | null
    register?: DateTimeNullableFilter | Date | string | null
    CLIENTS?: XOR<CLIENTSRelationFilter, CLIENTSWhereInput> | null
    PRODUCTS?: XOR<PRODUCTSRelationFilter, PRODUCTSWhereInput> | null
  }

  export type LIKESOrderByInput = {
    id?: SortOrder
    idproduct?: SortOrder
    idclient?: SortOrder
    register?: SortOrder
  }

  export type LIKESWhereUniqueInput = {
    id?: number
  }

  export type PRODUCTSWhereInput = {
    AND?: Enumerable<PRODUCTSWhereInput>
    OR?: Enumerable<PRODUCTSWhereInput>
    NOT?: Enumerable<PRODUCTSWhereInput>
    id?: StringFilter | string
    name?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    image?: FloatNullableFilter | number | null
    create?: DateTimeNullableFilter | Date | string | null
    LIKES?: LIKESListRelationFilter
  }

  export type PRODUCTSOrderByInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    create?: SortOrder
  }

  export type PRODUCTSWhereUniqueInput = {
    id?: string
  }

  export type SALESWhereInput = {
    AND?: Enumerable<SALESWhereInput>
    OR?: Enumerable<SALESWhereInput>
    NOT?: Enumerable<SALESWhereInput>
    idproduct?: StringNullableFilter | string | null
    idclient?: StringNullableFilter | string | null
    quantity?: IntNullableFilter | number | null
    register?: DateTimeNullableFilter | Date | string | null
    amount?: DecimalNullableFilter | Decimal | number | string | null
    id?: IntFilter | number
  }

  export type SALESOrderByInput = {
    idproduct?: SortOrder
    idclient?: SortOrder
    quantity?: SortOrder
    register?: SortOrder
    amount?: SortOrder
    id?: SortOrder
  }

  export type SALESWhereUniqueInput = {
    id?: number
  }

  export type CLIENTSCreateInput = {
    id: string
    name?: string | null
    password?: string | null
    state?: number | null
    LIKES?: LIKESCreateNestedManyWithoutCLIENTSInput
  }

  export type CLIENTSUncheckedCreateInput = {
    id: string
    name?: string | null
    password?: string | null
    state?: number | null
    LIKES?: LIKESUncheckedCreateNestedManyWithoutCLIENTSInput
  }

  export type CLIENTSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    LIKES?: LIKESUpdateManyWithoutCLIENTSInput
  }

  export type CLIENTSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
    LIKES?: LIKESUncheckedUpdateManyWithoutCLIENTSInput
  }

  export type CLIENTSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CLIENTSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LIKESCreateInput = {
    register?: Date | string | null
    CLIENTS?: CLIENTSCreateNestedOneWithoutLIKESInput
    PRODUCTS?: PRODUCTSCreateNestedOneWithoutLIKESInput
  }

  export type LIKESUncheckedCreateInput = {
    id?: number
    idproduct?: string | null
    idclient?: string | null
    register?: Date | string | null
  }

  export type LIKESUpdateInput = {
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CLIENTS?: CLIENTSUpdateOneWithoutLIKESInput
    PRODUCTS?: PRODUCTSUpdateOneWithoutLIKESInput
  }

  export type LIKESUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LIKESUpdateManyMutationInput = {
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LIKESUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PRODUCTSCreateInput = {
    id: string
    name?: string | null
    description?: string | null
    image?: number | null
    create?: Date | string | null
    LIKES?: LIKESCreateNestedManyWithoutPRODUCTSInput
  }

  export type PRODUCTSUncheckedCreateInput = {
    id: string
    name?: string | null
    description?: string | null
    image?: number | null
    create?: Date | string | null
    LIKES?: LIKESUncheckedCreateNestedManyWithoutPRODUCTSInput
  }

  export type PRODUCTSUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableFloatFieldUpdateOperationsInput | number | null
    create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LIKES?: LIKESUpdateManyWithoutPRODUCTSInput
  }

  export type PRODUCTSUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableFloatFieldUpdateOperationsInput | number | null
    create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    LIKES?: LIKESUncheckedUpdateManyWithoutPRODUCTSInput
  }

  export type PRODUCTSUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableFloatFieldUpdateOperationsInput | number | null
    create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PRODUCTSUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableFloatFieldUpdateOperationsInput | number | null
    create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SALESCreateInput = {
    idproduct?: string | null
    idclient?: string | null
    quantity?: number | null
    register?: Date | string | null
    amount?: Decimal | number | string | null
  }

  export type SALESUncheckedCreateInput = {
    idproduct?: string | null
    idclient?: string | null
    quantity?: number | null
    register?: Date | string | null
    amount?: Decimal | number | string | null
    id?: number
  }

  export type SALESUpdateInput = {
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
  }

  export type SALESUncheckedUpdateInput = {
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SALESUpdateManyMutationInput = {
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
  }

  export type SALESUncheckedUpdateManyInput = {
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    id?: IntFieldUpdateOperationsInput | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type LIKESListRelationFilter = {
    every?: LIKESWhereInput
    some?: LIKESWhereInput
    none?: LIKESWhereInput
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type CLIENTSRelationFilter = {
    is?: CLIENTSWhereInput | null
    isNot?: CLIENTSWhereInput | null
  }

  export type PRODUCTSRelationFilter = {
    is?: PRODUCTSWhereInput | null
    isNot?: PRODUCTSWhereInput | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type LIKESCreateNestedManyWithoutCLIENTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutCLIENTSInput>, Enumerable<LIKESUncheckedCreateWithoutCLIENTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutCLIENTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
  }

  export type LIKESUncheckedCreateNestedManyWithoutCLIENTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutCLIENTSInput>, Enumerable<LIKESUncheckedCreateWithoutCLIENTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutCLIENTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LIKESUpdateManyWithoutCLIENTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutCLIENTSInput>, Enumerable<LIKESUncheckedCreateWithoutCLIENTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutCLIENTSInput>
    upsert?: Enumerable<LIKESUpsertWithWhereUniqueWithoutCLIENTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
    set?: Enumerable<LIKESWhereUniqueInput>
    disconnect?: Enumerable<LIKESWhereUniqueInput>
    delete?: Enumerable<LIKESWhereUniqueInput>
    update?: Enumerable<LIKESUpdateWithWhereUniqueWithoutCLIENTSInput>
    updateMany?: Enumerable<LIKESUpdateManyWithWhereWithoutCLIENTSInput>
    deleteMany?: Enumerable<LIKESScalarWhereInput>
  }

  export type LIKESUncheckedUpdateManyWithoutCLIENTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutCLIENTSInput>, Enumerable<LIKESUncheckedCreateWithoutCLIENTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutCLIENTSInput>
    upsert?: Enumerable<LIKESUpsertWithWhereUniqueWithoutCLIENTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
    set?: Enumerable<LIKESWhereUniqueInput>
    disconnect?: Enumerable<LIKESWhereUniqueInput>
    delete?: Enumerable<LIKESWhereUniqueInput>
    update?: Enumerable<LIKESUpdateWithWhereUniqueWithoutCLIENTSInput>
    updateMany?: Enumerable<LIKESUpdateManyWithWhereWithoutCLIENTSInput>
    deleteMany?: Enumerable<LIKESScalarWhereInput>
  }

  export type CLIENTSCreateNestedOneWithoutLIKESInput = {
    create?: XOR<CLIENTSCreateWithoutLIKESInput, CLIENTSUncheckedCreateWithoutLIKESInput>
    connectOrCreate?: CLIENTSCreateOrConnectWithoutLIKESInput
    connect?: CLIENTSWhereUniqueInput
  }

  export type PRODUCTSCreateNestedOneWithoutLIKESInput = {
    create?: XOR<PRODUCTSCreateWithoutLIKESInput, PRODUCTSUncheckedCreateWithoutLIKESInput>
    connectOrCreate?: PRODUCTSCreateOrConnectWithoutLIKESInput
    connect?: PRODUCTSWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type CLIENTSUpdateOneWithoutLIKESInput = {
    create?: XOR<CLIENTSCreateWithoutLIKESInput, CLIENTSUncheckedCreateWithoutLIKESInput>
    connectOrCreate?: CLIENTSCreateOrConnectWithoutLIKESInput
    upsert?: CLIENTSUpsertWithoutLIKESInput
    connect?: CLIENTSWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<CLIENTSUpdateWithoutLIKESInput, CLIENTSUncheckedUpdateWithoutLIKESInput>
  }

  export type PRODUCTSUpdateOneWithoutLIKESInput = {
    create?: XOR<PRODUCTSCreateWithoutLIKESInput, PRODUCTSUncheckedCreateWithoutLIKESInput>
    connectOrCreate?: PRODUCTSCreateOrConnectWithoutLIKESInput
    upsert?: PRODUCTSUpsertWithoutLIKESInput
    connect?: PRODUCTSWhereUniqueInput
    disconnect?: boolean
    delete?: boolean
    update?: XOR<PRODUCTSUpdateWithoutLIKESInput, PRODUCTSUncheckedUpdateWithoutLIKESInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LIKESCreateNestedManyWithoutPRODUCTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutPRODUCTSInput>, Enumerable<LIKESUncheckedCreateWithoutPRODUCTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutPRODUCTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
  }

  export type LIKESUncheckedCreateNestedManyWithoutPRODUCTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutPRODUCTSInput>, Enumerable<LIKESUncheckedCreateWithoutPRODUCTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutPRODUCTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LIKESUpdateManyWithoutPRODUCTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutPRODUCTSInput>, Enumerable<LIKESUncheckedCreateWithoutPRODUCTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutPRODUCTSInput>
    upsert?: Enumerable<LIKESUpsertWithWhereUniqueWithoutPRODUCTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
    set?: Enumerable<LIKESWhereUniqueInput>
    disconnect?: Enumerable<LIKESWhereUniqueInput>
    delete?: Enumerable<LIKESWhereUniqueInput>
    update?: Enumerable<LIKESUpdateWithWhereUniqueWithoutPRODUCTSInput>
    updateMany?: Enumerable<LIKESUpdateManyWithWhereWithoutPRODUCTSInput>
    deleteMany?: Enumerable<LIKESScalarWhereInput>
  }

  export type LIKESUncheckedUpdateManyWithoutPRODUCTSInput = {
    create?: XOR<Enumerable<LIKESCreateWithoutPRODUCTSInput>, Enumerable<LIKESUncheckedCreateWithoutPRODUCTSInput>>
    connectOrCreate?: Enumerable<LIKESCreateOrConnectWithoutPRODUCTSInput>
    upsert?: Enumerable<LIKESUpsertWithWhereUniqueWithoutPRODUCTSInput>
    connect?: Enumerable<LIKESWhereUniqueInput>
    set?: Enumerable<LIKESWhereUniqueInput>
    disconnect?: Enumerable<LIKESWhereUniqueInput>
    delete?: Enumerable<LIKESWhereUniqueInput>
    update?: Enumerable<LIKESUpdateWithWhereUniqueWithoutPRODUCTSInput>
    updateMany?: Enumerable<LIKESUpdateManyWithWhereWithoutPRODUCTSInput>
    deleteMany?: Enumerable<LIKESScalarWhereInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string | null
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | null
    notIn?: Enumerable<Date> | Enumerable<string> | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type LIKESCreateWithoutCLIENTSInput = {
    register?: Date | string | null
    PRODUCTS?: PRODUCTSCreateNestedOneWithoutLIKESInput
  }

  export type LIKESUncheckedCreateWithoutCLIENTSInput = {
    id?: number
    idproduct?: string | null
    register?: Date | string | null
  }

  export type LIKESCreateOrConnectWithoutCLIENTSInput = {
    where: LIKESWhereUniqueInput
    create: XOR<LIKESCreateWithoutCLIENTSInput, LIKESUncheckedCreateWithoutCLIENTSInput>
  }

  export type LIKESUpsertWithWhereUniqueWithoutCLIENTSInput = {
    where: LIKESWhereUniqueInput
    update: XOR<LIKESUpdateWithoutCLIENTSInput, LIKESUncheckedUpdateWithoutCLIENTSInput>
    create: XOR<LIKESCreateWithoutCLIENTSInput, LIKESUncheckedCreateWithoutCLIENTSInput>
  }

  export type LIKESUpdateWithWhereUniqueWithoutCLIENTSInput = {
    where: LIKESWhereUniqueInput
    data: XOR<LIKESUpdateWithoutCLIENTSInput, LIKESUncheckedUpdateWithoutCLIENTSInput>
  }

  export type LIKESUpdateManyWithWhereWithoutCLIENTSInput = {
    where: LIKESScalarWhereInput
    data: XOR<LIKESUpdateManyMutationInput, LIKESUncheckedUpdateManyWithoutLIKESInput>
  }

  export type LIKESScalarWhereInput = {
    AND?: Enumerable<LIKESScalarWhereInput>
    OR?: Enumerable<LIKESScalarWhereInput>
    NOT?: Enumerable<LIKESScalarWhereInput>
    id?: IntFilter | number
    idproduct?: StringNullableFilter | string | null
    idclient?: StringNullableFilter | string | null
    register?: DateTimeNullableFilter | Date | string | null
  }

  export type CLIENTSCreateWithoutLIKESInput = {
    id: string
    name?: string | null
    password?: string | null
    state?: number | null
  }

  export type CLIENTSUncheckedCreateWithoutLIKESInput = {
    id: string
    name?: string | null
    password?: string | null
    state?: number | null
  }

  export type CLIENTSCreateOrConnectWithoutLIKESInput = {
    where: CLIENTSWhereUniqueInput
    create: XOR<CLIENTSCreateWithoutLIKESInput, CLIENTSUncheckedCreateWithoutLIKESInput>
  }

  export type PRODUCTSCreateWithoutLIKESInput = {
    id: string
    name?: string | null
    description?: string | null
    image?: number | null
    create?: Date | string | null
  }

  export type PRODUCTSUncheckedCreateWithoutLIKESInput = {
    id: string
    name?: string | null
    description?: string | null
    image?: number | null
    create?: Date | string | null
  }

  export type PRODUCTSCreateOrConnectWithoutLIKESInput = {
    where: PRODUCTSWhereUniqueInput
    create: XOR<PRODUCTSCreateWithoutLIKESInput, PRODUCTSUncheckedCreateWithoutLIKESInput>
  }

  export type CLIENTSUpsertWithoutLIKESInput = {
    update: XOR<CLIENTSUpdateWithoutLIKESInput, CLIENTSUncheckedUpdateWithoutLIKESInput>
    create: XOR<CLIENTSCreateWithoutLIKESInput, CLIENTSUncheckedCreateWithoutLIKESInput>
  }

  export type CLIENTSUpdateWithoutLIKESInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CLIENTSUncheckedUpdateWithoutLIKESInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PRODUCTSUpsertWithoutLIKESInput = {
    update: XOR<PRODUCTSUpdateWithoutLIKESInput, PRODUCTSUncheckedUpdateWithoutLIKESInput>
    create: XOR<PRODUCTSCreateWithoutLIKESInput, PRODUCTSUncheckedCreateWithoutLIKESInput>
  }

  export type PRODUCTSUpdateWithoutLIKESInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableFloatFieldUpdateOperationsInput | number | null
    create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PRODUCTSUncheckedUpdateWithoutLIKESInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableFloatFieldUpdateOperationsInput | number | null
    create?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LIKESCreateWithoutPRODUCTSInput = {
    register?: Date | string | null
    CLIENTS?: CLIENTSCreateNestedOneWithoutLIKESInput
  }

  export type LIKESUncheckedCreateWithoutPRODUCTSInput = {
    id?: number
    idclient?: string | null
    register?: Date | string | null
  }

  export type LIKESCreateOrConnectWithoutPRODUCTSInput = {
    where: LIKESWhereUniqueInput
    create: XOR<LIKESCreateWithoutPRODUCTSInput, LIKESUncheckedCreateWithoutPRODUCTSInput>
  }

  export type LIKESUpsertWithWhereUniqueWithoutPRODUCTSInput = {
    where: LIKESWhereUniqueInput
    update: XOR<LIKESUpdateWithoutPRODUCTSInput, LIKESUncheckedUpdateWithoutPRODUCTSInput>
    create: XOR<LIKESCreateWithoutPRODUCTSInput, LIKESUncheckedCreateWithoutPRODUCTSInput>
  }

  export type LIKESUpdateWithWhereUniqueWithoutPRODUCTSInput = {
    where: LIKESWhereUniqueInput
    data: XOR<LIKESUpdateWithoutPRODUCTSInput, LIKESUncheckedUpdateWithoutPRODUCTSInput>
  }

  export type LIKESUpdateManyWithWhereWithoutPRODUCTSInput = {
    where: LIKESScalarWhereInput
    data: XOR<LIKESUpdateManyMutationInput, LIKESUncheckedUpdateManyWithoutLIKESInput>
  }

  export type LIKESUpdateWithoutCLIENTSInput = {
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    PRODUCTS?: PRODUCTSUpdateOneWithoutLIKESInput
  }

  export type LIKESUncheckedUpdateWithoutCLIENTSInput = {
    id?: IntFieldUpdateOperationsInput | number
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LIKESUncheckedUpdateManyWithoutLIKESInput = {
    id?: IntFieldUpdateOperationsInput | number
    idproduct?: NullableStringFieldUpdateOperationsInput | string | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LIKESUpdateWithoutPRODUCTSInput = {
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    CLIENTS?: CLIENTSUpdateOneWithoutLIKESInput
  }

  export type LIKESUncheckedUpdateWithoutPRODUCTSInput = {
    id?: IntFieldUpdateOperationsInput | number
    idclient?: NullableStringFieldUpdateOperationsInput | string | null
    register?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}